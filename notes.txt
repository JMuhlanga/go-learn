Intro
==========

Go is cross-platform and open source, it can be used to create high-performance applications, it is fast statically typed, compiled language known for its simplicity and efficiency. Syntax is similar to C++.
Go is used for web development(server side), Developing network-based programs, developing cross-platform enterprise applications, cloud-native development. Built for running scaled,distributed systems.
Go has fast run time and compilation time, supports concurrency(Dealing with alot of things, tasks running parallel), has memory management, multiplatform. GO was designed to run on multiple cores and built to support concurrency.
Go Programs are organized into packages, Go's standard library provides different core packages for us to use.

GO Syntax
==========
A GO file consists of (package declaration, import packages, functions, statements and expressions)
i.e:
package main
import ("fmt")

func main() {
  fmt.Println("Hello World!")
}

In GO statements are separated by ending a line or adding a semi-colon (;), these statements are found in between curly braces

Comments in GO are written using - single line (//comment), and for multi line we use (/* comments */), we can use comments to prevent code execution

GO Variables
=========
Variables are stored once, assign it a name and use it in multiple places in the application code i.e (var name ="Go Conference").Var can be changed.
In GO there are different types of variables such as
i. int
ii. float32
iii. string
iv. bool
Constants are like variables, except that their values cannot be change.
In Go there are 2 ways of declaring a variable, using (var) keyword or using the (:=) sign i.e [var variableName type = value] or [variableName := value] not the last one cannot be used with constants.
In Go all variables are initialized sof if you declare a variable without an initial value its value will be set to the default value of its type
We can declare multiple variables in two ways in go
- In a single line we can use for example [var a, b, c, d int = 1, 3, 5, 7]
- In a block we can
    [
        var (
            a int
            b int = 1
            c string = "hello"
        )
   ]
Naming Rules for variables:
- A variable name must start with a letter or an underscore character (_)
- A variable cannot start with a digit
- A variable name can only contain alpha-numeric characters and underscores (a-z,A-Z,0-9 and _)
- Variable names are case-sensitive (age and AGE are different)
- There is no limit on the length of the variable name
- A variable name cannot contain spaces
- The variable name cannot be any Go keywords
Variable Names can be cameCased , PascalCased, snake_cased in Go
Constant Names are usually written in uppercase letters for easy identification and differentitation from variables
Constants can be declared both inside and outside of a function, just like variables we can declare multiple constants the same way

A pointer in go is a variable that stores the memory address of another variable. It allows you to indirectly access and modify the value of the variable it points to. Pointers are useful when you need to pass large data structures or modify values in functions without returning them explicitly.Also known as reference/ special variable.
Pointers are declared using the format [&variable_name]

&variable_name

This can also be used in getting user input in the console/terminal using the fmt.Scan() function.i.e
fmt.Scan(&variable_name) 


GO Outputs
==========
Go has 3 functions to ouput text [Print(),Println(),Printf()]
Print() prints its arguments with their default format.
Println() similar to Print() with the difference that a whitespace is added between the arguments and a newline is added at the end
Printf() function first formats its arguments based on the given formatting verb and then prints them.
Verb Formats include:
- %v - Prints the value in the default format
- %#v - Prints the value in go-syntax format
- %T - Prints the type of the value
- %% - Prints the % sign
There are various different ways to format variables based on also their type

GO Data Types
==========
Go has many data types, you need to tell Go Compiler, the data type when declaring the variable, Go can infer the type when you assign a value
Adding types makes a program more robust, reduces the likelihood of errors while it also helps developers to catch type mismatches sooner (at compile time)
Go has 3 basic data types - bool(true or false), Numeric(int,float,point and complex), strings
Go strings(string) are for text type variables
Go Boolean(bool) are for true or false

GO        Java
- int8 => byte
- int16 => short
- int32 => int
- int64 => long

int[n] - refers to sign integers, can be negative or positve while uint[8] refers to non-negative numbers, we use the bits to specify the amount of memory a variable can use to store the same
uint8 - unsigned 8 bit integers
uint16 - unsigned 16 bit integers
uint32 - unsigned 32 bit integers
uint64 - unsigned 64 bit integers
int8 - signed 8 bit integers
int16 - signed 16 bit integers
int32 - signed 32 bit integers
int64 - signed 64 bit integers

Floating point Types are typically used for numbers that contain a decimal point such as statistical data and monetary data, floats can have numbers that specify the amount of bits in memory that they can utilise

Arrays are used to store multiple values of the same type in a single variable, instead of declaring separate variables for each value, In Go we declare an array in two ways (var and :=), Array Syntax:
- var array_name = [length]datatype{values} here length is defined or var array_name = [...]datatype{values} here the array length is inferred
- array_name := [length]datatype{values} here length is defined or array_name := [...]datatype{values}
Example of how we use arrays
- var arr1 = [3]int{1,2,3}
- arr2 := [5]int{4,5,6,7,8}
- var arr3 = [...]int{1,2,3}
- arr4 = [...]int{4,5,6,7,8}
To access elements of an array in Go we use the index number that means that the first element is [o] and second element is [1], we use an example of the below to do the same
package main
import ("fmt")

func main() {
  prices := [3]int{10,20,30}

  fmt.Println(prices[0])
  fmt.Println(prices[2])
}
To change elements in an array we can use the same index number and reference it and change the item for example:
package main
import ("fmt")

func main() {
  prices := [3]int{10,20,30}

  prices[2] = 50
  fmt.Println(prices)
}
If an array or one of its elements has not been initialized in the code, it is assigned the default value of its type if its int then the default value is 0 if its a string it is ""
Its possible to initialize specific elements in an array
package main
import ("fmt")

func main() {
  arr1 := [5]int{1:10,2:40}

  fmt.Println(arr1)
} => [0 10 40 0 0]
The len() function is used to find the length of an array

Slices are similar to arrays but they are more flexible and can be resized dynamically. They are created using the make() function or by slicing an existing array. Syntax {slice_name := []datatype{values}} i.e {mySlice := []int()}
Here's an example:
package main
import ("fmt")

func main() {
  arr := [5]int{1,2,3,4,5}
  slice := arr[1:4]

  fmt.Println(slice)
}
len() -> returns the length
cap() -> returns the capacity of the slice (number of elements the slice can grow or shrink to)
You can create a slice by slicing an array
var myarray = [lenght]datatype{values} // An array
myslice := myarray[start:end] // A slice made from the array

example:

func main(){
    arr1 := [6]int{10,11,12,13,14,15}
    myslice := arr1[2:4]
    
    fmt.Printf("myslice = %v \n", myslice) // -> myslice = [12 13]
    fmt.Printf("length = %v \d",len(myslice)) // -> length = 2
    fmt.Printf("capacity = %v \d",cap(myslice)) // -> capacity = 4
} - myslice has a length of 2 made from arr1 which has length 6, slice starts from the 3rd element of the array which has value 12 the slice can grow at the end of the array meaning it has capacity of 4
The make function can also be used to create a slice i.e 
slice_name := make([]type,length, capacity), if the capacity param is not defined, it will be equal to length
func main(){
    myslice1 := make([]int,5,10)
    fmt.Printf("myslice1 = %v \n",myslice1) // -> myslice1 = [0 0 0 0 0]
    fmt.Printf("length = %d \n",len(myslice1)) // -> length = 5
    fmt.Printf("capacity = %d\n",cap(myslice1)) // -> capacity = 10
    
    myslice2 := make([]int,5)
    fmt.Printf("myslice2 = %v \n",myslice2) // -> myslice2 = [0 0 0 0 0]
    fmt.Printf("length = %d \n",len(myslice2)) // -> length = 5
    fmt.Printf("capacity = %d\n",cap(myslice2)) // -> capacity = 5
}
You can also change specific elements of a slice by referring to the index number 
func main(){
    prices := []int{10,20,30}
    prices[2] = 50
    fmt.Println(prices[2]) // -> 50
}
You can also append elements to the end of a slice using the {append()} function.
slice_name = append(slice_name,element1,element2,...)

func main(){
    myslice1 := []int{1,2,3,4,5,6}
    fmt.Printf("myslice1 = %v \n",myslice1) // -> myslice1 = [1 2 3 4 5 6]
    fmt.Printf("length = %d \n",len(myslice1)) // -> length = 6
    fmt.Printf("capacity = %d\n",cap(myslice1)) // -> capacity = 6
    
    myslice1 = append(myslice1, 20, 21)
    fmt.Printf("myslice1 = %v \n",myslice1) // -> myslice1 = [1 2 3 4 5 6 20 21]
    fmt.Printf("length = %d \n",len(myslice1)) // -> length = 8
    fmt.Printf("capacity = %d\n",cap(myslice1)) // -> capacity = 8
}
You can also append one slice to the other with {slice3 = append(slice1,slice2,...)}
If an array is large and you need only a few elements, it is better to copy those elements using the {copy()} function - > [copy(dest,src)] 
Copy function creates a new underlying array with only the required elements for the slice, this will reduce the memory used for the program 

GO OPERATORS
==========
Operators are used to perform operations on variables and values.

Arithmetic Operators
--------------------
+	Addition
-	Subtraction
*	Multiplication
/	Division
%	Modulus (remainder after division)
++	Increment (add 1)
--	Decrement (subtract 1)

Assignment Operators
--------------------
=	Simple assignment
+=	Add and assign
-=	Subtract and assign
*=	Multiply and assign
/=	Divide and assign
%=	Modulus and assign

Comparison Operators
--------------------
==	Equal to
!=	Not equal to
<	Less than
>	Greater than
<=	Less than or equal to
>=	Greater than or equal to

Logical Operators
-----------------
&&	Logical AND
||	Logical OR
!	Logical NOT

Bitwise Operators
-----------------
&	Bitwise AND
|	Bitwise OR
^	Bitwise XOR
<<	Left shift
>>	Right shift

GO Conditions
==========
Conditional statements are used to perform different actions based on different conditions
In general, languages provide various control structures to control the applications flow.
A loop statement allows us to execute code multiple times ,in a loop
A condition can either be [true] or [false], thus Go supports the usual comparison operators as well as logical operators
GO has the following conditional statements {if, else,else if,switch}
    [if] statements specify a block of code to be executed if a condition is true
        Syntax: 
            if condition {
                //code to be executed if condition is true
            }
    [else] statements are used to specify a block of code to be executed if the condition is false 
        Syntax:
            if condition {
            // code to be executed if condition is true
            } else {
            // code to be executed if condition is false
            }
    [else if] statements are used to specify a new condition if the first condition is false
        Syntax:
            if condition1 {
            // code to be executed if condition1 is true
            } else if condition2 {
            // code to be executed if condition1 is false and condition2 is true
            } else {
            // code to be executed if condition1 and condition2 are both false
            }
    [Nested if] statements are those if statements that have if statements within
        Syntax:
            if condition1 {
            // code to be executed if condition1 is true
                if condition2 {
                    // code to be executed if both condition1 and condition2 are true
                }
            }
    [switch] statements are used to select one of many code blocks to be executed. Only runs when the matched case so it does not need a break statement. The [default] keyword specifies some code to run in case there is not case match
        Syntax(single case):
            switch expression {
                case x:
                // code block
                case y:
                // code block
                case z:
                ...
                default:
                // code block
            }
        Syntax (Multi-case): Possible to have multiple values for each [case] in the [switch] statement
            switch expression {
                case x,y:
                // code block if expression is evaluated to x or y
                case v,w:
                // code block if expression is evaluated to v or w
                case z:
                ...
                default:
                // code block if expression is not found in any cases
            }

In GO loops are simplified we have [for] loops, loops through a block of code a specified number of times, this is the only loop available in GO
    Syntax:
        for statement1; statement2; statement3 {
            // code to be executed for each iteration
        }
        
    statement1 Initializes the loop counter value.
    
    statement2 Evaluated for each loop iteration. If it evaluates to TRUE, the loop continues. If it evaluates to FALSE, the loop ends.
    
    statement3 Increases the loop counter value.
    
    Example:
    
        for i:=0; i < 5; i++ {
            fmt.Println(i)
        }
The [continue] Statement is used to skip one or more iterations in the loop. It then continues with the next iteration in the loop, for example:

    package main
    import ("fmt")
    
    func main() {
        for i:=0; i < 5; i++ {
            if i == 3 {
                continue
            }
            fmt.Println(i) // -> 0 1 2 4
        }
    }    
The [break] statement is used to break/terminate the loop execution, example:
    package main
    import ("fmt")
    
    func main() {
        for i:=0; i < 5; i++ {
            if i == 3 {
                break
            }
            fmt.Println(i) // -> 0 1 2
        }
    }
It is possible to place a loop inside another loop, the "inner loop" will be executed one time for each iteration of the "outer loop",these are known as [nested loops] example:
    package main
    import ("fmt")
    
    func main() {
        adj := [2]string{"big", "tasty"}
        fruits := [3]string{"apple", "orange", "banana"}
        for i:=0; i < len(adj); i++ {
            for j:=0; j < len(fruits); j++ {
                fmt.Println(adj[i],fruits[j]) // - {big apple  big orange  big banana  tasty apple  tasty orange  tasty banana}
            }
        }
    }
The [range] keyword is used to more easily iterate through the elements of an array, slice or map. It returns both the index and the value. You can omit the output of one of the values using (_), Syntax:
    for index, value := range array|slice|map {
        // code to be executed for each iteration
    }
Example:
    package main
    import ("fmt")
    
    func main() {
        fruits := [3]string{"apple", "orange", "banana"}
        for idx, val := range fruits {
            fmt.Printf("%v\t%v\n", idx, val) // -> {0 apple  1 orange  2 banana}
        }
    }

GO Functions
==========
A function is a block of statements that can be used repeatedly in a program, it will not load automatically when an application loads, it will be executed by a call to the function
To create a function we use the [func] keyword, specify a name of the function followed by a parentheses (), then add the code for execution within the curly braces {}, Syntax:
    func FunctionName() {
    // code to be executed
    }
Then we call the function above with [FunctionName()], example:
    package main
    import ("fmt")
    
    func myMessage() {
        fmt.Println("I just got executed!")
    }
    
    func main() {
        myMessage() // call the function -> "I just got executed!"
    }
A function name must start with a letter, can only contain alpha-numeric characters and underscores [A-z,0-9 and _], function names are case sensitive, a function name cannot contain spaces, If the function name consists of multiple words, techniques introduced for multi-word variable naming can be used
Information can be passed to functions as a parameter, parameters can act as variables inside the function, parameters and their types are specified after the function name, inside the parentheses, you can add as many parameters as you want, just separate them with a comma, Syntax:
    func FunctionName(param1 type, param2 type, param3 type) {
        // code to be executed
    }
Example:
    package main
    import ("fmt")
    
    func familyName(fname string) {
        fmt.Println("Hello", fname, "Refsnes")
    }
    
    func main() {
        familyName("Liam") // -> Hello Liam Refsnes
        familyName("Jenny") // -> Hello Jenny Refsnes
        familyName("Anja") // -> Hello Anja Refsnes
    }
If you want the function to return a value you need to define the data type of the return value  (such as [int], [string], etc) and also use the [return] keyword inside the function, Syntax:
    func FunctionName(param1 type, param2 type) type {
        // code to be executed
        return output
    }
Example:
    package main
    import ("fmt")
    
    func myFunction(x int, y int) int {
        return x + y
    }
    
    func main() {
        fmt.Println(myFunction(1, 2)) // -> 3
    }    

In Go, you can name the return values of a function, Example:
    package main
    import ("fmt")
    
    func myFunction(x int, y int) (result int) {
        result = x + y
        return
    }
    
    func main() {
        total := myFunction(1,2) // we can store the return value in a varaible
        fmt.Println(total) // -> 3
    }
Go can also return multiple values ,Example:
    package main
    import ("fmt")
    
    func myFunction(x int, y string) (result int, txt1 string) {
        result = x + x
        txt1 = y + " World!"
        return
    }
    
    func main() {
        fmt.Println(myFunction(5, "Hello")) // -> 10 Hello World!
    }
In the event we do not want to return a particular value, or omit we can add _ to that value

Go Accepts recursion functions, a function is recursive if it calls itself and reaches a stop condition, Recursion is a common mathematical and programming concept meaning you can loop through data to reach a result. Example:
    package main
    import ("fmt")
    
    func factorial_recursion(x float64) (y float64) {
        if x > 0 {
            y = x * factorial_recursion(x-1)
        } else {
            y = 1
        }
        return
    }
    
    func main() {
        fmt.Println(factorial_recursion(4))
    }

GO Struct
==========
A struct (short for structure) is used to create a collection of members of different data types into a single variable, while arrays are used to store multiple values of the same data type into a single variable, structs are used to store multiple values of different data types into a single variable. They can be useful for grouping data together to create records
Declaring a struct:
    type struct_name struct {
        member1 datatype;
        member2 datatype;
        member3 datatype;
        ...
    }
Example of declaring a struct person with the following members name, age, job and salary:
    type Person struct {
        name string
        age int
        job string
        salary int
    }
To acces any member of a structure we use the (.) operator between the structure variable name and structure member, Example:
    package main
    import ("fmt")
    
    type Person struct {
        name string
        age int
        job string
        salary int
    }
    
    func main() {
        var pers1 Person
        var pers2 Person
        
        // Pers1 specification
        pers1.name = "Hege"
        pers1.age = 45
        pers1.job = "Teacher"
        pers1.salary = 6000
        
        // Pers2 specification
        pers2.name = "Cecilie"
        pers2.age = 24
        pers2.job = "Marketing"
        pers2.salary = 4500
        
        // Access and print Pers1 info
        fmt.Println("Name: ", pers1.name) //-> Name: Hege
        fmt.Println("Age: ", pers1.age) // -> Age: 45
        fmt.Println("Job: ", pers1.job) // -> Job: Teacher
        fmt.Println("Salary: ", pers1.salary) // -> Salary: 6000
        
        // Access and print Pers2 info
        fmt.Println("Name: ", pers2.name) // -> Name: Cecillie
        fmt.Println("Age: ", pers2.age) // -> Age: 24
        fmt.Println("Job: ", pers2.job) // -> Job: Marketing
        fmt.Println("Salary: ", pers2.salary) // -> Salary: 4500
    }
You can also pass a structure as an argument i.e
    // Print Pers1 info by calling a function
    printPerson(pers1)
    
    // Print Pers2 info by calling a function
    printPerson(pers2)
    func printPerson(pers Person) {
        fmt.Println("Name: ", pers.name)
        fmt.Println("Age: ", pers.age)
        fmt.Println("Job: ", pers.job)
        fmt.Println("Salary: ", pers.salary)
    }    
    
    the above prints
    /* 
        Name: Hege
        Age: 45
        Job: Teacher
        Salary: 6000
        Name: Cecilie
        Age: 24
        Job: Marketing
        Salary: 4500
    */
    
GO Maps
==========
Maps are used to store data values in key:value pairs like objects in other languages, Each element is a key:value pair.
A map is unordered and changeable collection that does not allow duplicates, thee length of a map is the number of its elements, you can find it using the [len()] function. 
The default value of a map is nil.
Maps hold reference to an underlying hash table
GO has multiple ways for creating maps

We can create maps using [var] and [:=], Syntax:
    var a = map[KeyType]ValueType{key1:value1, key2:value2,...}
    b := map[KeyType]ValueType{key1:value1, key2:value2,...}
Example:
    package main
    import ("fmt")
    
    func main() {
        var a = map[string]string{"brand": "Ford", "model": "Mustang", "year": "1964"}
        b := map[string]int{"Oslo": 1, "Bergen": 2, "Trondheim": 3, "Stavanger": 4}
        
        fmt.Printf("a\t%v\n", a)
        fmt.Printf("b\t%v\n", b)
    }
    
    /*
        a   map[brand:Ford model:Mustang year:1964]
        b   map[Bergen:2 Oslo:1 Stavanger:4 Trondheim:3]    
    */

We can create maps using the [make()] keyword, Syntax:
    var a = make(map[KeyType]ValueType)
    b := make(map[KeyType]ValueType)
Example:
    package main
    import ("fmt")
    
    func main() {
        var a = make(map[string]string) // The map is empty now
        a["brand"] = "Ford"
        a["model"] = "Mustang"
        a["year"] = "1964"
                                        // a is no longer empty
        b := make(map[string]int)
        b["Oslo"] = 1
        b["Bergen"] = 2
        b["Trondheim"] = 3
        b["Stavanger"] = 4
        
        fmt.Printf("a\t%v\n", a)
        fmt.Printf("b\t%v\n", b)
    }
    /*
        a   map[brand:Ford model:Mustang year:1964]
        b   map[Bergen:2 Oslo:1 Stavanger:4 Trondheim:3]
    */
    
We can also create an empty map, one by using the [make()] functioin and the other by using the Syntax below:
    var a map[KeyType]ValueType
Example:
    package main
    import ("fmt")
    
    func main() {
        var a = make(map[string]string)
        var b map[string]string
        
        fmt.Println(a == nil)
        fmt.Println(b == nil)
    }
    /*
        false
        true
    */
Allowed key types - the map key can be and data type for which the equality operator (==) is defined. Then inside include:
 - Booleans
 - Numbers
 - Strings
 - Arrays
 - Pointers
 - Structs
 - Interfaces(as long as the dynamic type supports equality)
Invalid key types are:
    - SLices
    - Maps
    - Functions
These types are invalid because the equality operator (==) is not defined for them

You can access map elements by , Syntax:
    value = map_name[key]
Example:
    package main
    import ("fmt")
    
    func main() {
        var a = make(map[string]string)
        a["brand"] = "Ford"
        a["model"] = "Mustang"
        a["year"] = "1964"
        
        fmt.Printf(a["brand"]) // -> Ford
    }
 
You can update and add Map elements by, Syntax:
    map_name[key] = value
Example:
    package main
    import ("fmt")
    
    func main() {
        var a = make(map[string]string)
        a["brand"] = "Ford"
        a["model"] = "Mustang"
        a["year"] = "1964"
        
        fmt.Println(a)
        
        a["year"] = "1970" // Updating an element
        a["color"] = "red" // Adding an element
        
        fmt.Println(a)
    }
    
    /*
        map[brand:Ford model:Mustang year:1964]
        map[brand:Ford color:red model:Mustang year:1970]
    */