Intro
==========

Go is cross-platform and open source, it can be used to create high-performance applications, it is fast statically typed, compiled language known for its simplicity and efficiency. Syntax is similar to C++.
Go is used for web development(server side), Developing network-based programs, developing cross-platform enterprise applications, cloud-native development. Built for running scaled,distributed systems.
Go has fast run time and compilation time, supports concurrency(Dealing with alot of things, tasks running parallel), has memory management, multiplatform. GO was designed to run on multiple cores and built to support concurrency.
Go Programs are organized into packages, Go's standard library provides different core packages for us to use.

GO Syntax
==========
A GO file consists of (package declaration, import packages, functions, statements and expressions)
i.e:
package main
import ("fmt")

func main() {
  fmt.Println("Hello World!")
}

In GO statements are separated by ending a line or adding a semi-colon (;), these statements are found in between curly braces

Comments in GO are written using - single line (//comment), and for multi line we use (/* comments */), we can use comments to prevent code execution

GO Variables
=========
Variables are stored once, assign it a name and use it in multiple places in the application code i.e (var name ="Go Conference").Var can be changed.
In GO there are different types of variables such as
i. int
ii. float32
iii. string
iv. bool
Constants are like variables, except that their values cannot be change.
In Go there are 2 ways of declaring a variable, using (var) keyword or using the (:=) sign i.e [var variableName type = value] or [variableName := value] not the last one cannot be used with constants.
In Go all variables are initialized sof if you declare a variable without an initial value its value will be set to the default value of its type
We can declare multiple variables in two ways in go
- In a single line we can use for example [var a, b, c, d int = 1, 3, 5, 7]
- In a block we can
    [
        var (
            a int
            b int = 1
            c string = "hello"
        )
   ]
Naming Rules for variables:
- A variable name must start with a letter or an underscore character (_)
- A variable cannot start with a digit
- A variable name can only contain alpha-numeric characters and underscores (a-z,A-Z,0-9 and _)
- Variable names are case-sensitive (age and AGE are different)
- There is no limit on the length of the variable name
- A variable name cannot contain spaces
- The variable name cannot be any Go keywords
Variable Names can be cameCased , PascalCased, snake_cased in Go
Constant Names are usually written in uppercase letters for easy identification and differentitation from variables
Constants can be declared both inside and outside of a function, just like variables we can declare multiple constants the same way

GO Outputs
==========
Go has 3 functions to ouput text [Print(),Println(),Printf()]
Print() prints its arguments with their default format.
Println() similar to Print() with the difference that a whitespace is added between the arguments and a newline is added at the end
Printf() function first formats its arguments based on the given formatting verb and then prints them.
Verb Formats include:
- %v - Prints the value in the default format
- %#v - Prints the value in go-syntax format
- %T - Prints the type of the value
- %% - Prints the % sign
There are various different ways to format variables based on also their type

GO Data Types
==========
Go has many data types, you need to tell Go Compiler, the data type when declaring the variable, Go can infer the type when you assign a value
Adding types makes a program more robust, reduces the likelihood of errors while it also helps developers to catch type mismatches sooner (at compile time)
Go has 3 basic data types - bool(true or false), Numeric(int,float,point and complex), strings
Go strings(string) are for text type variables
Go Boolean(bool) are for true or false

GO        Java
- int8 => byte
- int16 => short
- int32 => int
- int64 => long

int[n] - refers to sign integers, can be negative or positve while uint[8] refers to non-negative numbers, we use the bits to specify the amount of memory a variable can use to store the same
uint8 - unsigned 8 bit integers
uint16 - unsigned 16 bit integers
uint32 - unsigned 32 bit integers
uint64 - unsigned 64 bit integers
int8 - signed 8 bit integers
int16 - signed 16 bit integers
int32 - signed 32 bit integers
int64 - signed 64 bit integers

Floating point Types are typically used for numbers that contain a decimal point such as statistical data and monetary data, floats can have numbers that specify the amount of bits in memory that they can utilise

Arrays are used to store multiple values of the same type in a single variable, instead of declaring separate variables for each value, In Go we declare an array in two ways (var and :=), Array Syntax:
- var array_name = [length]datatype{values} here length is defined or var array_name = [...]datatype{values} here the array length is inferred
- array_name := [length]datatype{values} here length is defined or array_name := [...]datatype{values}
Example of how we use arrays
- var arr1 = [3]int{1,2,3}
- arr2 := [5]int{4,5,6,7,8}
- var arr3 = [...]int{1,2,3}
- arr4 = [...]int{4,5,6,7,8}
To access elements of an array in Go we use the index number that means that the first element is [o] and second element is [1], we use an example of the below to do the same
package main
import ("fmt")

func main() {
  prices := [3]int{10,20,30}

  fmt.Println(prices[0])
  fmt.Println(prices[2])
}
To change elements in an array we can use the same index number and reference it and change the item for example:
package main
import ("fmt")

func main() {
  prices := [3]int{10,20,30}

  prices[2] = 50
  fmt.Println(prices)
}
If an array or one of its elements has not been initialized in the code, it is assigned the default value of its type if its int then the default value is 0 if its a string it is ""
Its possible to initialize specific elements in an array
package main
import ("fmt")

func main() {
  arr1 := [5]int{1:10,2:40}

  fmt.Println(arr1)
} => [0 10 40 0 0]
The len() function is used to find the length of an array

Slices are similar to arrays but they are more flexible and can be resized dynamically. They are created using the make() function or by slicing an existing array. Syntax {slice_name := []datatype{values}} i.e {mySlice := []int()}
Here's an example:
package main
import ("fmt")

func main() {
  arr := [5]int{1,2,3,4,5}
  slice := arr[1:4]

  fmt.Println(slice)
}
len() -> returns the length
cap() -> returns the capacity of the slice (number of elements the slice can grow or shrink to)
You can create a slice by slicing an array
var myarray = [lenght]datatype{values} // An array
myslice := myarray[start:end] // A slice made from the array

example:

func main(){
    arr1 := [6]int{10,11,12,13,14,15}
    myslice := arr1[2:4]
    
    fmt.Printf("myslice = %v \n", myslice) // -> myslice = [12 13]
    fmt.Printf("length = %v \d",len(myslice)) // -> length = 2
    fmt.Printf("capacity = %v \d",cap(myslice)) // -> capacity = 4
} - myslice has a length of 2 made from arr1 which has length 6, slice starts from the 3rd element of the array which has value 12 the slice can grow at the end of the array meaning it has capacity of 4
The make function can also be used to create a slice i.e 
slice_name := make([]type,length, capacity), if the capacity param is not defined, it will be equal to length
func main(){
    myslice1 := make([]int,5,10)
    fmt.Printf("myslice1 = %v \n",myslice1) // -> myslice1 = [0 0 0 0 0]
    fmt.Printf("length = %d \n",len(myslice1)) // -> length = 5
    fmt.Printf("capacity = %d\n",cap(myslice1)) // -> capacity = 10
    
    myslice2 := make([]int,5)
    fmt.Printf("myslice2 = %v \n",myslice2) // -> myslice2 = [0 0 0 0 0]
    fmt.Printf("length = %d \n",len(myslice2)) // -> length = 5
    fmt.Printf("capacity = %d\n",cap(myslice2)) // -> capacity = 5
}
You can also change specific elements of a slice by referring to the index number 
func main(){
    prices := []int{10,20,30}
    prices[2] = 50
    fmt.Println(prices[2]) // -> 50
}
You can also append elements to the end of a slice using the {append()} function.
slice_name = append(slice_name,element1,element2,...)

func main(){
    myslice1 := []int{1,2,3,4,5,6}
    fmt.Printf("myslice1 = %v \n",myslice1) // -> myslice1 = [1 2 3 4 5 6]
    fmt.Printf("length = %d \n",len(myslice1)) // -> length = 6
    fmt.Printf("capacity = %d\n",cap(myslice1)) // -> capacity = 6
    
    myslice1 = append(myslice1, 20, 21)
    fmt.Printf("myslice1 = %v \n",myslice1) // -> myslice1 = [1 2 3 4 5 6 20 21]
    fmt.Printf("length = %d \n",len(myslice1)) // -> length = 8
    fmt.Printf("capacity = %d\n",cap(myslice1)) // -> capacity = 8
}
You can also append one slice to the other with {slice3 = append(slice1,slice2,...)}
If an array is large and you need only a few elements, it is better to copy those elements using the {copy()} function - > [copy(dest,src)] 
Copy function creates a new underlying array with only the required elements for the slice, this will reduce the memory used for the program 